//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/libcore/luni/src/main/java/java/util/concurrent/locks/AbstractQueuedSynchronizer.java
//

#ifndef _JavaUtilConcurrentLocksAbstractQueuedSynchronizer_H_
#define _JavaUtilConcurrentLocksAbstractQueuedSynchronizer_H_

@class JavaLangThread;
@class JavaUtilConcurrentLocksAbstractQueuedSynchronizer_ConditionObject;
@class JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node;
@class JavaUtilConcurrentTimeUnitEnum;
@class JavaUtilDate;
@class SunMiscUnsafe;
@protocol JavaUtilCollection;

#import "JreEmulation.h"
#include "java/io/Serializable.h"
#include "java/util/concurrent/locks/AbstractOwnableSynchronizer.h"
#include "java/util/concurrent/locks/Condition.h"

#define JavaUtilConcurrentLocksAbstractQueuedSynchronizer_serialVersionUID 7373984972572414691LL
#define JavaUtilConcurrentLocksAbstractQueuedSynchronizer_spinForTimeoutThreshold 1000LL

@interface JavaUtilConcurrentLocksAbstractQueuedSynchronizer : JavaUtilConcurrentLocksAbstractOwnableSynchronizer < JavaIoSerializable > {
}

- (instancetype)init;

- (jint)getState;

- (void)setStateWithInt:(jint)newState;

- (jboolean)compareAndSetStateWithInt:(jint)expect
                              withInt:(jint)update;

+ (void)selfInterrupt;

- (jboolean)acquireQueuedWithJavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node:(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *)node
                                                                            withInt:(jint)arg;

- (jboolean)tryAcquireWithInt:(jint)arg;

- (jboolean)tryReleaseWithInt:(jint)arg;

- (jint)tryAcquireSharedWithInt:(jint)arg;

- (jboolean)tryReleaseSharedWithInt:(jint)arg;

- (jboolean)isHeldExclusively;

- (void)acquireWithInt:(jint)arg;

- (void)acquireInterruptiblyWithInt:(jint)arg;

- (jboolean)tryAcquireNanosWithInt:(jint)arg
                          withLong:(jlong)nanosTimeout;

- (jboolean)release__WithInt:(jint)arg;

- (void)acquireSharedWithInt:(jint)arg;

- (void)acquireSharedInterruptiblyWithInt:(jint)arg;

- (jboolean)tryAcquireSharedNanosWithInt:(jint)arg
                                withLong:(jlong)nanosTimeout;

- (jboolean)releaseSharedWithInt:(jint)arg;

- (jboolean)hasQueuedThreads;

- (jboolean)hasContended;

- (JavaLangThread *)getFirstQueuedThread;

- (jboolean)isQueuedWithJavaLangThread:(JavaLangThread *)thread;

- (jboolean)apparentlyFirstQueuedIsExclusive;

- (jboolean)hasQueuedPredecessors;

- (jint)getQueueLength;

- (id<JavaUtilCollection>)getQueuedThreads;

- (id<JavaUtilCollection>)getExclusiveQueuedThreads;

- (id<JavaUtilCollection>)getSharedQueuedThreads;

- (NSString *)description;

- (jboolean)isOnSyncQueueWithJavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node:(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *)node;

- (jboolean)transferForSignalWithJavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node:(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *)node;

- (jboolean)transferAfterCancelledWaitWithJavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node:(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *)node;

- (jint)fullyReleaseWithJavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node:(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *)node;

- (jboolean)ownsWithJavaUtilConcurrentLocksAbstractQueuedSynchronizer_ConditionObject:(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_ConditionObject *)condition;

- (jboolean)hasWaitersWithJavaUtilConcurrentLocksAbstractQueuedSynchronizer_ConditionObject:(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_ConditionObject *)condition;

- (jint)getWaitQueueLengthWithJavaUtilConcurrentLocksAbstractQueuedSynchronizer_ConditionObject:(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_ConditionObject *)condition;

- (id<JavaUtilCollection>)getWaitingThreadsWithJavaUtilConcurrentLocksAbstractQueuedSynchronizer_ConditionObject:(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_ConditionObject *)condition;

@end

FOUNDATION_EXPORT BOOL JavaUtilConcurrentLocksAbstractQueuedSynchronizer_initialized;
J2OBJC_STATIC_INIT(JavaUtilConcurrentLocksAbstractQueuedSynchronizer)
FOUNDATION_EXPORT void JavaUtilConcurrentLocksAbstractQueuedSynchronizer_selfInterrupt();

J2OBJC_STATIC_FIELD_GETTER(JavaUtilConcurrentLocksAbstractQueuedSynchronizer, serialVersionUID, jlong)

J2OBJC_STATIC_FIELD_GETTER(JavaUtilConcurrentLocksAbstractQueuedSynchronizer, spinForTimeoutThreshold, jlong)

FOUNDATION_EXPORT SunMiscUnsafe *JavaUtilConcurrentLocksAbstractQueuedSynchronizer_unsafe_;
J2OBJC_STATIC_FIELD_GETTER(JavaUtilConcurrentLocksAbstractQueuedSynchronizer, unsafe_, SunMiscUnsafe *)

FOUNDATION_EXPORT jlong JavaUtilConcurrentLocksAbstractQueuedSynchronizer_stateOffset_;
J2OBJC_STATIC_FIELD_GETTER(JavaUtilConcurrentLocksAbstractQueuedSynchronizer, stateOffset_, jlong)

FOUNDATION_EXPORT jlong JavaUtilConcurrentLocksAbstractQueuedSynchronizer_headOffset_;
J2OBJC_STATIC_FIELD_GETTER(JavaUtilConcurrentLocksAbstractQueuedSynchronizer, headOffset_, jlong)

FOUNDATION_EXPORT jlong JavaUtilConcurrentLocksAbstractQueuedSynchronizer_tailOffset_;
J2OBJC_STATIC_FIELD_GETTER(JavaUtilConcurrentLocksAbstractQueuedSynchronizer, tailOffset_, jlong)

FOUNDATION_EXPORT jlong JavaUtilConcurrentLocksAbstractQueuedSynchronizer_waitStatusOffset_;
J2OBJC_STATIC_FIELD_GETTER(JavaUtilConcurrentLocksAbstractQueuedSynchronizer, waitStatusOffset_, jlong)

FOUNDATION_EXPORT jlong JavaUtilConcurrentLocksAbstractQueuedSynchronizer_nextOffset_;
J2OBJC_STATIC_FIELD_GETTER(JavaUtilConcurrentLocksAbstractQueuedSynchronizer, nextOffset_, jlong)

#define JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node_CANCELLED 1
#define JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node_CONDITION -2
#define JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node_PROPAGATE -3
#define JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node_SIGNAL -1

@interface JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node : NSObject {
 @public
  jint waitStatus_;
  JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *prev_;
  JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *next_;
  JavaLangThread *thread_;
  JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *nextWaiter_;
}

- (jboolean)isShared;

- (JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *)predecessor;

- (instancetype)init;

- (instancetype)initWithJavaLangThread:(JavaLangThread *)thread
withJavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node:(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *)mode;

- (instancetype)initWithJavaLangThread:(JavaLangThread *)thread
                               withInt:(jint)waitStatus;

@end

FOUNDATION_EXPORT BOOL JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node_initialized;
J2OBJC_STATIC_INIT(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node, prev_, JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node, next_, JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node, thread_, JavaLangThread *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node, nextWaiter_, JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *)

FOUNDATION_EXPORT JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node_SHARED_;
J2OBJC_STATIC_FIELD_GETTER(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node, SHARED_, JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *)

FOUNDATION_EXPORT JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node_EXCLUSIVE_;
J2OBJC_STATIC_FIELD_GETTER(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node, EXCLUSIVE_, JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *)

J2OBJC_STATIC_FIELD_GETTER(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node, CANCELLED, jint)

J2OBJC_STATIC_FIELD_GETTER(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node, SIGNAL, jint)

J2OBJC_STATIC_FIELD_GETTER(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node, CONDITION, jint)

J2OBJC_STATIC_FIELD_GETTER(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node, PROPAGATE, jint)

#define JavaUtilConcurrentLocksAbstractQueuedSynchronizer_ConditionObject_REINTERRUPT 1
#define JavaUtilConcurrentLocksAbstractQueuedSynchronizer_ConditionObject_THROW_IE -1
#define JavaUtilConcurrentLocksAbstractQueuedSynchronizer_ConditionObject_serialVersionUID 1173984872572414699LL

@interface JavaUtilConcurrentLocksAbstractQueuedSynchronizer_ConditionObject : NSObject < JavaUtilConcurrentLocksCondition, JavaIoSerializable > {
}

- (instancetype)initWithJavaUtilConcurrentLocksAbstractQueuedSynchronizer:(JavaUtilConcurrentLocksAbstractQueuedSynchronizer *)outer$;

- (void)signal;

- (void)signalAll;

- (void)awaitUninterruptibly;

- (void)await;

- (jlong)awaitNanosWithLong:(jlong)nanosTimeout;

- (jboolean)awaitUntilWithJavaUtilDate:(JavaUtilDate *)deadline;

- (jboolean)awaitWithLong:(jlong)time
withJavaUtilConcurrentTimeUnitEnum:(JavaUtilConcurrentTimeUnitEnum *)unit;

- (jboolean)isOwnedByWithJavaUtilConcurrentLocksAbstractQueuedSynchronizer:(JavaUtilConcurrentLocksAbstractQueuedSynchronizer *)sync;

- (jboolean)hasWaiters;

- (jint)getWaitQueueLength;

- (id<JavaUtilCollection>)getWaitingThreads;

@end

__attribute__((always_inline)) inline void JavaUtilConcurrentLocksAbstractQueuedSynchronizer_ConditionObject_init() {}

J2OBJC_STATIC_FIELD_GETTER(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_ConditionObject, serialVersionUID, jlong)

J2OBJC_STATIC_FIELD_GETTER(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_ConditionObject, REINTERRUPT, jint)

J2OBJC_STATIC_FIELD_GETTER(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_ConditionObject, THROW_IE, jint)

#endif // _JavaUtilConcurrentLocksAbstractQueuedSynchronizer_H_
